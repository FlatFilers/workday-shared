import { IterableContainer } from './_types';
type Direction = 'asc' | 'desc';
type SortProjection<T> = (x: T) => Comparable;
type ComparablePrimitive = number | string | boolean;
type Comparable = ComparablePrimitive | {
    valueOf(): ComparablePrimitive;
};
type SortPair<T> = readonly [SortProjection<T>, Direction];
type SortRule<T> = SortProjection<T> | SortPair<T>;
export declare function sortBy<T>(sort: SortRule<T>, ...sorts: Array<SortRule<T>>): (array: ReadonlyArray<T>) => Array<T>;
export declare function sortBy<T>(array: ReadonlyArray<T>, ...sorts: Array<SortRule<T>>): Array<T>;
interface Strict {
    <T extends IterableContainer>(sort: SortRule<T[number]>, ...sorts: Array<SortRule<T[number]>>): (data: T) => SortedBy<T>;
    <T extends IterableContainer>(data: T, ...sorts: Array<SortRule<T[number]>>): SortedBy<T>;
}
type SortedBy<T extends IterableContainer> = {
    -readonly [P in keyof T]: T[number];
};
export declare namespace sortBy {
    const strict: Strict;
}
export {};
//# sourceMappingURL=sortBy.d.ts.map