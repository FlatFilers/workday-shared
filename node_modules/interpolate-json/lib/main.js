"use strict";const extend=require("extend"),type=require("type-detect"),{BadRequest}=require("custom-exception"),{subtract}=require("./set-operations"),{RegexEscaped,FixRegexStickyTest}=require("./regexp-extensions"),spaces="[\\s]*",paramExpressionSet="[\\w]+",allowedFuncExpressions="{}()+-_*/%:|?,.$!&#'",funcExpressionSet=`[\\s\\w${RegexEscaped("{}()+-_*/%:|?,.$!&#'")}]+`,allowedOperators=["==","===","!=","!==","<","<=",">",">="],getOperatorSet=allowedOperators.map((e=>RegexEscaped(e))).join("|"),acceptedValueTypes=new Set(["number","string","boolean"]),isArgument=(e,t)=>e&&type(e)===(t||type(e)),isFunction=e=>"function"===type(e),envPrefix="INTERPOLATE_OPTION_",debugEnv=`${envPrefix}DEBUG`,isDebug=()=>"true"===(process.env[debugEnv]||"").toString().toLowerCase(),log=e=>{isDebug()&&console.log(`[interpolate-json][debug]: ${e}`)},trace=e=>{isDebug()&&console.trace(`[interpolate-json][error]: ${e}`)},traceNThrow=(e,t)=>{throw trace(e),"Exception"===type(t)?new t(e):new Error(e)},InterpolateOption=function(e="${",t="}",r="."){let n={};const _checkSuffix=()=>{n.suffix=n.suffix?n.suffix:""},_defineFixedProperties=e=>{Object.defineProperty(e,"funcSpecifier",{value:"=",writable:!1,enumerable:!1}),Object.defineProperty(e,"escapeSpecifier",{value:"*",writable:!1,enumerable:!1})};return n.updateOption=(e,t=!1)=>{const r=isArgument(e,"Object");for(let s in n)if(i=n[s],"function"!==type(i)){let i,o=`${envPrefix}${s.toUpperCase()}`;r&&(i=t?o:s),n[s]=r&&e.hasOwnProperty(i)?e[i]:process.env[o]||n[s]}var i;return _checkSuffix(),n},n.clone=()=>{var e={...n};return _defineFixedProperties(e),e},n.cloneFrom=e=>("InterpolateOption"===type(e)&&(n.prefix=e.prefix,n.suffix=e.suffix,n.subKeyPointer=e.subKeyPointer),_checkSuffix(),n),n[Symbol.toStringTag]="InterpolateOption",n.prefix=e,n.suffix=t,n.subKeyPointer=r,_defineFixedProperties(n),_checkSuffix(),n},Interpolation=function(e=InterpolateOption()){let t,r,n,i,s={},o=null;const _updateRegex=()=>{r=_getParamRegex(),n=_getFuncRegex(o),i=_getEscapeRegex()},_updateOption=(e,t=!1)=>{o.updateOption(e,t),_updateRegex()},_getParamRegex=e=>{let t=new RegExp(RegexEscaped(o.prefix)+(isArgument(e,"string")?RegexEscaped(e):"")+`(${spaces}[\\w]+`+`(?:(${RegexEscaped(o.subKeyPointer)})[\\w]+)*`+`${o.suffix?spaces:""})`+RegexEscaped(o.suffix),"g");return FixRegexStickyTest(t),t},_getFuncRegex=(e,t=!1)=>{let r=new RegExp(RegexEscaped(e.prefix)+(t?"((":"")+RegexEscaped(e.funcSpecifier)+(t?")?":"")+`(${spaces}${funcExpressionSet}`+`(?:(${getOperatorSet})${funcExpressionSet})*${spaces})`+(t?"(":"")+RegexEscaped(e.funcSpecifier)+(t?")?)":"")+RegexEscaped(e.suffix),"g");return FixRegexStickyTest(r),r},_getEscapeRegex=()=>{let e=o.clone();return e.prefix='"'+e.prefix.trim()+e.escapeSpecifier.trim(),e.suffix=e.suffix.trim()+'"',_getFuncRegex(e,!0)},_missingKeyKeepAlive=e=>`${o.prefix}${e}${o.suffix}`,_getMatchSet=e=>new Set(e.reduce(((e,t)=>(e.push(t.replace(r,((e,t)=>t.trim()))),e)),[])),_getInterpolated=(e,t,n=!1)=>(log(`Found match: ${e.match(r)}`),e.replace(r,((e,r)=>(r=r.trim(),t.hasOwnProperty(r)?t[r].toString():n?e:"")))),_getInterpolatedFunc=(e,t,i=!1)=>(log(`Found func match: ${e.match(n)}`),e.replace(n,((e,n)=>{let i={};return n=n.trim().replace(r,((e,r)=>(i[r]=t.hasOwnProperty(r)?t[r].toString():"",`$val['${r}']`))),new Function("$val",`return ${n}`)(i)}))),_flattenAndResolve=(e,t,i,s=!1)=>{let p=i||{};return t.forEach((t=>{if(p.hasOwnProperty(t))return;let i=!1,a=((e,t,r=!1)=>{const n=t.split(o.subKeyPointer).reduce(((e,t)=>e[t]||{}),e);return acceptedValueTypes.has(type(n))?n:r?_missingKeyKeepAlive(t):""})(e,t,s);_missingKeyKeepAlive(t)!==a&&r.nonStickyTest(a)&&(p=_flattenAndResolve(e,subtract(_getMatchSet(a.match(r)),new Set(Object.keys(p))),p,s),i=!0),n.nonStickyTest(a)&&(a=_getInterpolatedFunc(a,p)),i&&r.nonStickyTest(a)&&(a=_getInterpolated(a,p,s)),p[t]=a})),p},_containsOption=e=>Object.keys(e).some((e=>e.startsWith(envPrefix)));return s.expand=(e,n=null,s=null)=>{let p=!1,a=!1;const c=type(e);isArgument(s,"Object")||isArgument(s,"InterpolateOption")?(s.prefix&&!s.suffix&&(s.suffix=""),_updateOption(s),a=!0):isArgument(n,"Object")&&_containsOption(n)?(_updateOption(n,!0),a=!0):isArgument(e,"Object")&&_containsOption(e)&&(_updateOption(e,!0),a=!0);var u={};switch(c){case"Object":case"Array":let t=JSON.stringify(e);i.nonStickyTest(t)&&(e=JSON.parse(t.replace(i,((e,t)=>e.replace(`${o.prefix.trim()}${o.escapeSpecifier.trim()}`,`${o.prefix.trim()}`)))),t=(e=>e.replace(i,((e,t)=>`${o.prefix}${t.trim()}${o.suffix}`)))(t)),u=extend(u,e,n||{}),e=t;break;case"string":log(`Input: "${e}"`),r.nonStickyTest(e)&&null===n&&traceNThrow('Please provide "values"',BadRequest),u=extend(u,n);break;default:return trace(`Interpolation for ${c} has not yet been implemented`),e}log(`before interpolation:\n${e}`);let l="";if(r.nonStickyTest(e)){const t=e.match(r);n=_flattenAndResolve(u,_getMatchSet(t)),log(`all values: ${JSON.stringify(n,null,2)}`),p=!0}switch(p?(l=_getInterpolatedFunc(e,n),l=_getInterpolated(l,n)):l=e,log(`after interpolation:\n${l}`),a&&(o.cloneFrom(t),_updateRegex()),c){case"Object":case"Array":return JSON.parse(l);default:return l}},s.debug=(e=!0)=>(process.env[debugEnv]=e.toString(),s),"InterpolateOption"!==type(e)&&traceNThrow('Please provide "values"',BadRequest),s[Symbol.toStringTag]="Interpolation",o=e,o.updateOption(),null!==o&&(t=o.clone()),_updateRegex(),s};module.exports={InterpolateOption,Interpolation,interpolation:Interpolation(),RegexEscaped};