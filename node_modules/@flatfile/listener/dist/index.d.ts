import { Event, RecordsWithLinks } from '@flatfile/api/api';
import { Flatfile } from '@flatfile/api';

declare class AuthenticatedClient {
    _accessToken?: string;
    _apiUrl?: string;
    constructor(accessToken?: string, apiUrl?: string);
    fetch(url: string, options?: any): Promise<any>;
    /**
     *
     * @deprecated use @flatfile/cross-env-config instead
     */
    setVariables({ accessToken, apiUrl, }: {
        accessToken?: string;
        apiUrl?: string;
    }): void;
}

declare class EventCache {
    private eventCache;
    init<T>(key: string, callback: () => Promise<T>): Promise<T>;
    set<T>(key: string, callback: () => Promise<T>): Promise<T>;
    get<T>(key: string): T;
    delete(key?: string | string[]): void;
}

type GetDataOptions = {
    [key: string]: any;
};
interface GetData extends Function {
    (options?: GetDataOptions): Promise<any>;
    then<TResult1 = any, TResult2 = any>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
}
declare class FlatfileEvent extends AuthenticatedClient {
    private readonly src;
    /**
     * Event ID from the API
     *
     * @example us0_ev_82hgidh9skd
     * @readonly
     *
     */
    readonly id?: string;
    /**
     * Topic the event was produced on
     *
     * @example workbook:created
     * @readonly
     */
    readonly topic: string;
    readonly domain: string;
    readonly target: string;
    readonly origin: object;
    readonly action: string;
    readonly context: any;
    readonly payload: any;
    readonly cache: EventCache;
    readonly namespace: string[];
    /**
     * Fetch record data from Flatfile API via the event's dataUrl
     *
     * @async
     * @param {object} options
     * @returns {Promise<any>} JSON
     */
    data: GetData;
    constructor(src: Event, accessToken?: string, apiUrl?: string);
    /**
     * Should return either event body if expanded already or fetch data from the
     * signed dataURL
     */
    private fetchData;
    private afterAllCallbacks;
    afterAll<T>(callback: () => T, cacheKey?: string): void;
    update(records: RecordsWithLinks): Promise<void>;
    /**
     * Fetch the Secrets as indicated by this event context
     *
     * @param key - The name of the secret to fetch
     * @param options - (Optional) environmentId and spaceId to override event context
     *
     * @returns The value of the secret (usually a credential or token)
     */
    secrets(key: string, options?: {
        environmentId?: string;
        spaceId?: string;
    }): Promise<string>;
}
type EventCallback = (evt: FlatfileEvent) => void;

/**
 * EventHandler is a Flatfile flavored implementation of EventTarget
 */
declare class EventHandler extends AuthenticatedClient {
    /**
     * Apply a filter to the values of an event
     */
    readonly filterQuery?: EventFilter;
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    protected listeners: [string | string[], EventFilter, EventCallback][];
    constructor(filter?: EventFilter, accessToken?: string, apiUrl?: string);
    /**
     * Cache of registered child nodes for this listener. These nodes will
     * only receive events that pass the parent filter.
     *
     * @private
     */
    protected nodes: EventHandler[];
    /**
     * Register a subscriber for events that match this path
     */
    on(query: Arrayable<string>, callback: EventCallback): this;
    on(query: Arrayable<string>, filter: EventFilter, callback: EventCallback): this;
    /**
     * Add child nodes to send this event to as well
     *
     * @param node
     */
    addNode(node: EventHandler): this;
    /**
     * Dispatch an event and resolve the promise once it has completed (or
     * errored
     *
     * @todo - is there a right order in which to resolve event listeners?
     *   Should it matter?
     *
     * @param event
     */
    dispatchEvent(event: FlatfileEvent | Flatfile.Event | any): Promise<void>;
    /**
     * @deprecated legacy shim for receiving events from the VM layer
     * @alias dispatchEvent
     * @param event
     */
    routeEvent(event: Flatfile.Event): Promise<void>;
    /**
     * Actually trigger the event listeners on this particular target
     *
     * @note It is safer for now to run this in series to avoid IO locks and
     *       potential race conditions and uncaught errors
     *
     * @param event
     * @param recursive
     */
    trigger(event: FlatfileEvent, recursive?: boolean): Promise<void>;
    /**
     * Get any listeners from this target subscribing to this event
     *
     * @param event
     * @param recursive
     */
    getListeners(event: FlatfileEvent, recursive?: boolean): Listener[];
    /**
     * Attach more event listeners using a callback function. Used most
     * frequently for plugins.
     *
     * @param fn
     */
    use(fn: (handler: this) => void): this;
    /**
     * Filter an event out based on glob filter object
     *
     * @param event
     * @param filter
     */
    matchEvent(event: FlatfileEvent, filter: EventFilter | undefined): boolean;
}
type EventFilter = Record<string, any>;
type Arrayable<T> = T | Array<T>;
type Listener = {
    query: string | string[];
    filter: any;
    callback: EventCallback;
};

declare abstract class EventDriver {
    _handler?: EventHandler;
    get handler(): EventHandler;
    /**
     * Mount an event handler
     *
     * @param handler
     */
    mountEventHandler(handler: EventHandler): this;
    /**
     * Dispatch an event
     *
     * @param e
     */
    dispatchEvent(e: any): this;
}

declare class Browser extends EventDriver {
    _accessToken?: string;
    _apiUrl?: string;
    _environmentId?: string;
    constructor({ apiUrl, accessToken, environmentId, }: {
        apiUrl: string;
        accessToken: string;
        environmentId?: string;
        /**
         * @deprecated
         */
        fetchApi: any;
    });
    mountEventHandler(handler: EventHandler): this;
}

/**
 * Flatfile's Virtual Machine is stateless / serverless. So when a new event
 * is handled, it will just call `handle(event)`.
 */
declare class FlatfileVirtualMachine extends EventDriver {
    /**
     * This method is triggered from within the Flatfile Core VM Runner. This
     * EventDriver does not have to listen for events because this method will
     * be invoked as necessary.
     *
     * @param event
     */
    handle(event: FlatfileEvent): void;
    mountEventHandler(handler: EventHandler): this;
}

/**
 * The Flatfile Listener
 *
 * The Flatfile PubSub Client is just a simple event subscriber. It can
 * receive events from any PubSub driver. The default drivers are:
 *
 * - Webhook    (for simply processing events sent to URL)
 * - Websocket  (for subscribing real time on an HTTP2 connection)
 * - Serverless (for stateless invocations via AWS Lambda or similar)
 *
 * Once an event is received, it is routed to any awaiting listeners which
 * are added with `addEventListener()` or its alias `on()`.
 *
 * Flatfile events follow a standard structure and event listeners can use
 * any of the following syntaxes to react to events within Flatfile.
 *
 * // listen to an event
 * addEventListener('entity:topic')
 *
 * // listen to an event on a specific namespace
 * addEventListener('entity:topic@namespace')
 *
 * // listen to a specific context on a namespace
 * addEventListener('entity:topic@namespace?context=us_sp_89234oihsdo')
 *
 * // filter by any
 * addEventListener('entity:topic@namespace?')
 *
 */

declare class FlatfileListener extends EventHandler {
    /**
     * Subscribe to events only within a certain namespace.
     *
     * @param namespace
     * @param cb
     */
    namespace(namespaces: string | string[], cb?: SubFn<this>): this;
    /**
     * Filter by namespace
     *
     * @param filter
     * @param cb
     */
    filter(filter: EventFilter, cb?: SubFn<this>): this;
    /**
     * Start subscribing to events
     *
     * @param cb
     */
    static create<T extends FlatfileListener>(this: Constructor<T>, cb: SubFn<T>): T;
    /**
     * Mount this client using an acceptable Event Driver
     */
    mount(driver: EventDriver): this;
}
type SubFn<T extends FlatfileListener> = (client: T) => void;
type Constructor<T> = {
    new (): T;
};

/**
 * Backwards compatibility
 */
declare class Client extends FlatfileListener {
}

export { Arrayable, AuthenticatedClient, Browser, Client, EventCallback, EventDriver, EventFilter, EventHandler, FlatfileEvent, FlatfileListener, FlatfileVirtualMachine, Listener };
