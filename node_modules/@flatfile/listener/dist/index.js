"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AuthenticatedClient: () => AuthenticatedClient,
  Browser: () => Browser,
  Client: () => Client,
  EventDriver: () => EventDriver,
  EventHandler: () => EventHandler,
  FlatfileEvent: () => FlatfileEvent,
  FlatfileListener: () => FlatfileListener,
  FlatfileVirtualMachine: () => FlatfileVirtualMachine
});
module.exports = __toCommonJS(src_exports);

// ../cross-env-config/dist/index.mjs
var CrossEnvConfig = class {
  /**
   * Get a config value from either the environment or any registry overrides
   * @param prop
   */
  static get(prop) {
    return this.safeEnvLookup(prop);
  }
  /**
   * Set a value explicitly
   *
   * @param key
   * @param value
   */
  static set(key, value) {
    return this._overrides.set(key, value);
  }
  /**
   * Alias a key to another key if helpful. This is useful if you have different naming
   * constructs for different environments.
   *
   * @param from
   * @param to
   */
  static alias(from, to) {
    return this._aliases.set(from, to);
  }
  /**
   * Helpful if you've decided to store settings in another object and want to
   * make that available here. For example in client-side implementations you may reserve
   * a window.FLATFILE_CONFIG object to store settings.
   *
   * @param obj
   */
  static attachConfigRegistry(obj) {
    this._registry = obj;
  }
  /**
   * Use this to provide an override getter for config values. This is useful
   * if you need to dynamically look up values. Overrides will still take precedence.
   *
   * @param cb
   */
  static attachConfigFactory(cb) {
    this._factory = cb;
  }
  static reset() {
    this._overrides = /* @__PURE__ */ new Map();
    this._registry = void 0;
    this._factory = void 0;
  }
  /**
   * Internal function for traversing the possible environment sources for a value
   *
   * @param prop
   * @private
   */
  static safeEnvLookup(prop) {
    let values = [];
    if (this._overrides.get(prop)) {
      values.push(this._overrides.get(prop));
    }
    if (typeof this._registry === "object") {
      values.push(this._registry[prop]);
    }
    if (typeof this._factory === "function") {
      values.push(this._factory(prop));
    }
    if (typeof process === "object" && typeof process.env === "object") {
      values.push(process.env[prop]);
    }
    values.push(...this.checkForBrowserVariables(prop));
    const foundValue = values.find((v) => v !== void 0);
    if (foundValue !== void 0) {
      return foundValue;
    }
    const alias = this._aliases.get(prop);
    if (alias) {
      return this.safeEnvLookup(alias);
    }
    return void 0;
  }
  /**
   * Internal function for checking for stored variables in a browser-like environment
   *
   * @param prop
   * @private
   */
  static checkForBrowserVariables(prop) {
    let values = [];
    if (typeof window === "object") {
      const windowValue = window[`CROSSENV_${prop}`];
      if (windowValue !== void 0) {
        values.push(windowValue);
      }
      if (typeof sessionStorage === "object") {
        const storedValue = sessionStorage.getItem(`CROSSENV_${prop}`);
        if (storedValue !== null) {
          values.push(storedValue);
        }
      }
    }
    return values;
  }
};
CrossEnvConfig._overrides = /* @__PURE__ */ new Map();
CrossEnvConfig._aliases = /* @__PURE__ */ new Map();

// src/events/authenticated.client.ts
var import_axios = __toESM(require("axios"));
var AuthenticatedClient = class {
  constructor(accessToken, apiUrl) {
    const FLATFILE_API_URL = CrossEnvConfig.get("AGENT_INTERNAL_URL") || "http://localhost:3000";
    const bearerToken = CrossEnvConfig.get("FLATFILE_BEARER_TOKEN");
    this._accessToken = accessToken || bearerToken || "...";
    this._apiUrl = apiUrl || FLATFILE_API_URL;
  }
  async fetch(url, options) {
    const headers = {
      Authorization: `Bearer ${this._accessToken}`,
      "x-disable-hooks": "true"
    };
    const axiosInstance = import_axios.default.create({
      headers
    });
    const fetchUrl = this._apiUrl + "/" + url;
    const config = {
      url: fetchUrl,
      method: "GET",
      ...options
    };
    try {
      const resp = await axiosInstance(config);
      return resp.data.data;
    } catch (err) {
    }
  }
  /**
   *
   * @deprecated use @flatfile/cross-env-config instead
   */
  setVariables({
    accessToken,
    apiUrl
  }) {
    this._accessToken = accessToken;
    this._apiUrl = apiUrl;
  }
};

// src/events/cache.ts
var EventCache = class {
  constructor() {
    this.eventCache = /* @__PURE__ */ new Map();
  }
  async init(key, callback) {
    if (this.eventCache.get(key)) {
      return this.eventCache.get(key);
    } else {
      const result = await callback();
      this.eventCache.set(key, result);
      return result;
    }
  }
  async set(key, callback) {
    if (this.eventCache.get(key)) {
      const result = await callback();
      this.eventCache.set(key, result);
      return result;
    } else {
      throw new Error("Cache key not found");
    }
  }
  get(key) {
    if (this.eventCache.get(key)) {
      return this.eventCache.get(key);
    } else {
      throw new Error("Cache key not found");
    }
  }
  delete(key) {
    if (!key) {
      this.eventCache.clear();
    } else if (this.eventCache.get(key)) {
      if (Array.isArray(key)) {
        key.forEach((k) => this.eventCache.delete(k));
      } else {
        this.eventCache.delete(key);
      }
    } else {
      throw new Error("Cache key not found");
    }
  }
};

// src/events/flatfile.event.ts
var FlatfileEvent = class extends AuthenticatedClient {
  constructor(src, accessToken, apiUrl) {
    super(accessToken, apiUrl);
    this.src = src;
    this.afterAllCallbacks = /* @__PURE__ */ new Map();
    this.cache = new EventCache();
    this.domain = src.domain;
    this.topic = src.topic;
    this.context = src.context;
    this.payload = src.payload;
    this.target = src.target || "";
    this.origin = src.origin || {};
    this.action = src.context?.actionName || "";
  }
  /**
   * Should return either event body if expanded already or fetch data from the
   * signed callback URL
   *
   * @todo this should work with the included callback URL
   */
  get data() {
    if (this.src.dataUrl) {
      return this.fetch(this.src.dataUrl);
    } else {
      return this.payload;
    }
  }
  afterAll(callback, cacheKey) {
    const key = cacheKey || callback.toString();
    if (!this.afterAllCallbacks.get(key)) {
      this.afterAllCallbacks.set(key, callback);
    }
  }
  async update(records) {
    if (!this.src.dataUrl) {
      throw new Error("Cannot set data on an event without a dataUrl");
    }
    const prepRecords = records.map((record) => {
      record.messages?.map((message) => {
        delete message.source;
      });
    });
    await this.fetch(this.src.dataUrl, {
      method: "POST",
      data: JSON.stringify(prepRecords)
    });
  }
};

// ../../node_modules/wildcard-match/build/index.es.mjs
function escapeRegExpChar(char) {
  if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") {
    return "\\" + char;
  } else {
    return char;
  }
}
function escapeRegExpString(str) {
  var result = "";
  for (var i = 0; i < str.length; i++) {
    result += escapeRegExpChar(str[i]);
  }
  return result;
}
function transform(pattern, separator) {
  if (separator === void 0) {
    separator = true;
  }
  if (Array.isArray(pattern)) {
    var regExpPatterns = pattern.map(function(p) {
      return "^" + transform(p, separator) + "$";
    });
    return "(?:" + regExpPatterns.join("|") + ")";
  }
  var separatorSplitter = "";
  var separatorMatcher = "";
  var wildcard = ".";
  if (separator === true) {
    separatorSplitter = "/";
    separatorMatcher = "[/\\\\]";
    wildcard = "[^/\\\\]";
  } else if (separator) {
    separatorSplitter = separator;
    separatorMatcher = escapeRegExpString(separatorSplitter);
    if (separatorMatcher.length > 1) {
      separatorMatcher = "(?:" + separatorMatcher + ")";
      wildcard = "((?!" + separatorMatcher + ").)";
    } else {
      wildcard = "[^" + separatorMatcher + "]";
    }
  }
  var requiredSeparator = separator ? separatorMatcher + "+?" : "";
  var optionalSeparator = separator ? separatorMatcher + "*?" : "";
  var segments = separator ? pattern.split(separatorSplitter) : [pattern];
  var result = "";
  for (var s = 0; s < segments.length; s++) {
    var segment = segments[s];
    var nextSegment = segments[s + 1];
    var currentSeparator = "";
    if (!segment && s > 0) {
      continue;
    }
    if (separator) {
      if (s === segments.length - 1) {
        currentSeparator = optionalSeparator;
      } else if (nextSegment !== "**") {
        currentSeparator = requiredSeparator;
      } else {
        currentSeparator = "";
      }
    }
    if (separator && segment === "**") {
      if (currentSeparator) {
        result += s === 0 ? "" : currentSeparator;
        result += "(?:" + wildcard + "*?" + currentSeparator + ")*?";
      }
      continue;
    }
    for (var c = 0; c < segment.length; c++) {
      var char = segment[c];
      if (char === "\\") {
        if (c < segment.length - 1) {
          result += escapeRegExpChar(segment[c + 1]);
          c++;
        }
      } else if (char === "?") {
        result += wildcard;
      } else if (char === "*") {
        result += wildcard + "*?";
      } else {
        result += escapeRegExpChar(char);
      }
    }
    result += currentSeparator;
  }
  return result;
}
function isMatch(regexp, sample) {
  if (typeof sample !== "string") {
    throw new TypeError("Sample must be a string, but " + typeof sample + " given");
  }
  return regexp.test(sample);
}
function wildcardMatch(pattern, options) {
  if (typeof pattern !== "string" && !Array.isArray(pattern)) {
    throw new TypeError("The first argument must be a single pattern string or an array of patterns, but " + typeof pattern + " given");
  }
  if (typeof options === "string" || typeof options === "boolean") {
    options = { separator: options };
  }
  if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) {
    throw new TypeError("The second argument must be an options object or a string/boolean separator, but " + typeof options + " given");
  }
  options = options || {};
  if (options.separator === "\\") {
    throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
  }
  var regexpPattern = transform(pattern, options.separator);
  var regexp = new RegExp("^" + regexpPattern + "$", options.flags);
  var fn = isMatch.bind(null, regexp);
  fn.options = options;
  fn.pattern = pattern;
  fn.regexp = regexp;
  return fn;
}
var index_es_default = wildcardMatch;

// src/events/glob.match.ts
var import_flat = __toESM(require("flat"));
function glob(val, filter) {
  if (!val || typeof val !== "string") {
    return false;
  }
  return index_es_default(filter || "**", ":")(val);
}
function objectMatches(object, filterObject) {
  const cleanFilter = !filterObject || typeof filterObject !== "object" ? { "**": filterObject } : filterObject;
  if (typeof object !== "object") {
    throw new Error("You cannot filter a non-object");
  }
  let denied = false;
  const filter = (0, import_flat.default)(cleanFilter, { safe: true });
  const flattened = (0, import_flat.default)(object, { safe: true });
  for (const keyPattern in filter) {
    const keys = filterKeys(flattened, keyPattern);
    const valuePattern = Array.isArray(filter[keyPattern]) ? filter[keyPattern] : [filter[keyPattern]];
    denied || (denied = !keys.some((key) => {
      const value = flattened[key];
      return valuePattern.some((match) => globOrMatch(value, match));
    }));
  }
  return !denied;
}
function filterKeys(object, glob2) {
  glob2 = glob2.includes("*") || glob2.includes(".") ? glob2 : `**.${glob2}`;
  const matcher = index_es_default(glob2, ".");
  return Object.keys(object).filter((key) => matcher(key));
}
function globOrMatch(val, filter) {
  if (val === void 0 || val === null) {
    return filter === null;
  }
  if (Array.isArray(val)) {
    return val.some((v) => globOrMatch(v, filter));
  }
  if (typeof filter === "string") {
    return glob(val.toString(), filter);
  }
  return val === filter;
}

// src/events/event.handler.ts
var EventHandler = class extends AuthenticatedClient {
  constructor(filter, accessToken, apiUrl) {
    super(accessToken, apiUrl);
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    this.listeners = [];
    /**
     * Cache of registered child nodes for this listener. These nodes will
     * only receive events that pass the parent filter.
     *
     * @private
     */
    this.nodes = [];
    if (filter) {
      this.filterQuery = filter;
    }
  }
  on(query, ...rest) {
    let filter = {};
    const callback = rest.pop();
    if (rest.length) {
      filter = rest.shift();
    }
    this.listeners.push([query, filter, callback]);
    return this;
  }
  /**
   * Add child nodes to send this event to as well
   *
   * @param node
   */
  addNode(node) {
    this.nodes.push(node);
    return this;
  }
  /**
   * Dispatch an event and resolve the promise once it has completed (or
   * errored
   *
   * @todo - is there a right order in which to resolve event listeners?
   *   Should it matter?
   *
   * @param event
   */
  async dispatchEvent(event) {
    if (!(event instanceof FlatfileEvent)) {
      event = new FlatfileEvent(event, this._accessToken, this._apiUrl);
      if (this._apiUrl && this._accessToken) {
        event.setVariables({
          apiUrl: this._apiUrl,
          accessToken: this._accessToken
        });
      }
    }
    await this.trigger(event, true);
    for (const [_key, cb] of event.afterAllCallbacks) {
      await cb(event);
    }
    event.cache.delete();
  }
  /**
   * @deprecated legacy shim for receiving events from the VM layer
   * @alias dispatchEvent
   * @param event
   */
  async routeEvent(event) {
    return this.dispatchEvent(event);
  }
  /**
   * Actually trigger the event listeners on this particular target
   *
   * @note It is safer for now to run this in series to avoid IO locks and
   *       potential race conditions and uncaught errors
   *
   * @param event
   * @param recursive
   */
  async trigger(event, recursive = false) {
    const listeners = this.getListeners(event, recursive);
    for (const cb of listeners) {
      await cb.callback(event);
    }
  }
  /**
   * Get any listeners from this target subscribing to this event
   *
   * @param event
   * @param recursive
   */
  getListeners(event, recursive = false) {
    if (!this.matchEvent(event, this.filterQuery)) {
      return [];
    }
    const listeners = this.listeners.filter(([query, filter]) => {
      const globbed = glob(event.topic, query);
      const matched = this.matchEvent(event, filter);
      return globbed && matched;
    }).map(([query, filter, callback]) => ({ query, filter, callback }));
    return !recursive ? listeners : [
      ...listeners,
      ...this.nodes.flatMap((n) => n.getListeners(event, true))
    ];
  }
  /**
   * Attach more event listeners using a callback function. Used most
   * frequently for plugins.
   *
   * @param fn
   */
  use(fn) {
    fn(this);
    return this;
  }
  /**
   * Filter an event out based on glob filter object
   *
   * @param event
   * @param filter
   */
  matchEvent(event, filter) {
    return filter ? objectMatches(event, filter) : true;
  }
};

// src/flatfile.listener.ts
var FlatfileListener = class extends EventHandler {
  /**
   * Subscribe to events only within a certain namespace.
   *
   * @param namespace
   * @param cb
   */
  namespace(namespace, cb) {
    return this.filter({ namespace }, cb);
  }
  /**
   * Filter by namespace
   *
   * @param filter
   * @param cb
   */
  filter(filter, cb) {
    const client = new this.constructor(filter);
    this.addNode(client);
    cb?.(client);
    return client;
  }
  /**
   * Start subscribing to events
   *
   * @param cb
   */
  static create(cb) {
    const client = new this();
    cb(client);
    return client;
  }
  /**
   * Mount this client using an acceptable Event Driver
   */
  mount(driver) {
    driver.mountEventHandler(this);
    return this;
  }
};

// src/event-drivers/_EventDriver.ts
var EventDriver = class {
  get handler() {
    if (!this._handler) {
      throw new Error("handler not registered yet");
    }
    return this._handler;
  }
  /**
   * Mount an event handler
   *
   * @param handler
   */
  mountEventHandler(handler) {
    this._handler = handler;
    return this;
  }
  /**
   * Dispatch an event
   *
   * @param e
   */
  dispatchEvent(e) {
    this.handler.dispatchEvent(e);
    return this;
  }
};

// src/event-drivers/Browser.ts
var Browser = class extends EventDriver {
  constructor({
    apiUrl,
    accessToken,
    environmentId
  }) {
    super();
    this._apiUrl = apiUrl;
    this._accessToken = accessToken;
    this._environmentId = environmentId || "";
  }
  mountEventHandler(handler) {
    handler.setVariables({
      accessToken: this._accessToken,
      apiUrl: this._apiUrl
    });
    this._handler = handler;
    return this;
  }
};

// src/event-drivers/FlatfileVirtualMachine.ts
var FlatfileVirtualMachine = class extends EventDriver {
  /**
   * This method is triggered from within the Flatfile Core VM Runner. This
   * EventDriver does not have to listen for events because this method will
   * be invoked as necessary.
   *
   * @param event
   */
  handle(event) {
    this.dispatchEvent(event);
  }
  mountEventHandler(handler) {
    this._handler = handler;
    return this;
  }
};

// src/index.ts
var Client = class extends FlatfileListener {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthenticatedClient,
  Browser,
  Client,
  EventDriver,
  EventHandler,
  FlatfileEvent,
  FlatfileListener,
  FlatfileVirtualMachine
});
