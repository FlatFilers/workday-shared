// src/excel.extractor.ts
import * as XLSX from "xlsx";
import { mapKeys, mapValues as mapValues2 } from "remeda";

// src/abstract.extractor.ts
import {
  FlatfileClient
} from "@flatfile/api";
import { mapValues } from "remeda";
var AbstractExtractor = class {
  constructor(event) {
    this.event = event;
    this.fileId = event.context.fileId || "";
    this.api = new FlatfileClient();
  }
  /**
   * Download file data from Flatfile
   */
  async getFileBufferFromApi() {
    const file = await this.api.files.download(this.fileId);
    const chunks = [];
    for await (const chunk of file) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks);
  }
  /**
   * Start a job on the API referencing the extraction. This will all reporting completion
   * to the user when the extraction is completed.
   */
  async startJob() {
    try {
      const res = await this.api.jobs.create({
        type: "file",
        operation: "extract",
        status: "executing",
        source: this.fileId,
        // TODO: This should be configurable
        managed: true
      });
      if (!res || !res.data) {
        throw new Error(`Unable to create job: ${JSON.stringify(res)}`);
      }
      return res.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Complete a previously started extraction job. This will notify the UI that the extraction
   * is ready.
   *
   * @param job
   */
  async completeJob(job) {
    try {
      const res = await this.api.jobs.update(job.id, {
        status: "complete"
      });
      return res.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Create workbook on server mactching schema structure and attach to the file
   *
   * @param file
   * @param workbookCapture
   */
  async createWorkbook(file, workbookCapture) {
    const workbookConfig = this.getWorkbookConfig(
      file.name,
      this.event.context.spaceId,
      this.event.context.environmentId,
      workbookCapture
    );
    try {
      const workbook = await this.api.workbooks.create(workbookConfig);
      if (!workbook || !workbook.data) {
        throw new Error(
          `Unable to create workbook: ${JSON.stringify(workbook)}`
        );
      }
      await this.api.files.update(file.id, { workbookId: workbook.data?.id });
      return workbook.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Convert the data from each sheet into created records
   *
   * @todo some verification that rows can't contain non-header data
   * @param sheet
   * @private
   */
  makeAPIRecords(sheet) {
    return sheet.data.map((row) => {
      return mapValues(row, (value) => ({ value }));
    });
  }
  /**
   * Get a workbook configuration to post to the API
   *
   * @param name
   * @param spaceId
   * @param environmentId
   * @param workbookCapture
   * @private
   */
  getWorkbookConfig(name, spaceId, environmentId, workbookCapture) {
    const sheets = Object.values(
      mapValues(workbookCapture, (sheet, sheetName) => {
        return this.getSheetConfig(sheetName, sheet);
      })
    );
    return {
      name: `[file] ${name}`,
      labels: ["file"],
      spaceId,
      environmentId,
      sheets
    };
  }
  /**
   * Construct a sheet configuration for the extracted sheet
   *
   * @param name
   * @param headers
   * @param required
   * @param descriptions
   * @private
   */
  getSheetConfig(name, { headers, required, descriptions }) {
    return {
      name,
      fields: headers.map((key) => ({
        key,
        label: key,
        description: descriptions?.[key] || "",
        type: "string",
        constraints: required?.[key] ? [{ type: "required" }] : []
      }))
    };
  }
};

// src/excel.extractor.ts
var ExcelExtractor = class extends AbstractExtractor {
  constructor(event, options) {
    super(event);
    this.event = event;
    this.options = options;
    this._options = { rawNumbers: false, ...options };
  }
  /**
   * Parse a file buffer into a captured sheet
   *
   * @param buffer
   */
  parseBuffer(buffer) {
    const workbook = XLSX.read(buffer, {
      type: "buffer",
      cellDates: true
    });
    return mapValues2(workbook.Sheets, (value, key) => {
      return this.convertSheet(value);
    });
  }
  /**
   * Convert a template sheet using a special template format
   *
   * @param sheet
   */
  convertSheet(sheet) {
    let rows = XLSX.utils.sheet_to_json(sheet, {
      header: "A",
      defval: null,
      rawNumbers: this._options.rawNumbers || false
    });
    const hasHeader = this.isHeaderCandidate(rows[0]);
    const colMap = hasHeader ? rows.shift() : null;
    if (colMap) {
      const headers = mapValues2(colMap, (val) => val?.replace("*", ""));
      const required = mapValues2(colMap, (val) => val?.includes("*"));
      const data = rows.map((row) => mapKeys(row, (key) => headers[key]));
      return {
        headers: Object.values(headers).filter((v) => v),
        required: mapKeys(required, (k) => headers[k]),
        data
      };
    } else {
      return { headers: Object.keys(rows[0]), data: rows };
    }
  }
  /**
   * Extract the data from an uploaded XLSX file
   */
  async runExtraction() {
    try {
      const { data: file } = await this.api.files.get(this.fileId);
      if (file.ext !== "xlsx") {
        return false;
      }
      const job = await this.startJob();
      const buffer = await this.getFileBufferFromApi();
      const capture = this.parseBuffer(buffer);
      const workbook = await this.createWorkbook(file, capture);
      if (!workbook?.sheets)
        return false;
      for (const sheet of workbook.sheets) {
        if (!capture[sheet.name]) {
          continue;
        }
        const recordsData = this.makeAPIRecords(capture[sheet.name]);
        await this.api.records.insert(sheet.id, recordsData);
      }
      await this.completeJob(job);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * This needs to be improved but right now it looks for a pattern unlikely
   * to be in a header.
   *
   * Yes header | foo | bar | baz |
   * No header  | 99  | asd | 0   |
   *
   * @param header
   */
  isHeaderCandidate(header) {
    if (!header) {
      return false;
    }
    return !Object.values(header).some(
      (v) => typeof v === "string" ? /^[0-9]+$/.test(v) : !!v
    );
  }
};
export {
  ExcelExtractor
};
