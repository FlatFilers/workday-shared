"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ExcelExtractor: () => ExcelExtractor
});
module.exports = __toCommonJS(src_exports);

// src/excel.extractor.ts
var XLSX = __toESM(require("xlsx"));
var import_remeda2 = require("remeda");

// src/abstract.extractor.ts
var import_api = require("@flatfile/api");
var import_remeda = require("remeda");
var AbstractExtractor = class {
  constructor(event) {
    this.event = event;
    this.fileId = event.context.fileId || "";
    this.api = new import_api.FlatfileClient();
  }
  /**
   * Download file data from Flatfile
   */
  async getFileBufferFromApi() {
    const file = await this.api.files.download(this.fileId);
    const chunks = [];
    for await (const chunk of file) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks);
  }
  /**
   * Start a job on the API referencing the extraction. This will all reporting completion
   * to the user when the extraction is completed.
   */
  async startJob() {
    try {
      const res = await this.api.jobs.create({
        type: "file",
        operation: "extract",
        status: "executing",
        source: this.fileId,
        // TODO: This should be configurable
        managed: true
      });
      if (!res || !res.data) {
        throw new Error(`Unable to create job: ${JSON.stringify(res)}`);
      }
      return res.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Complete a previously started extraction job. This will notify the UI that the extraction
   * is ready.
   *
   * @param job
   */
  async completeJob(job) {
    try {
      const res = await this.api.jobs.update(job.id, {
        status: "complete"
      });
      return res.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Create workbook on server mactching schema structure and attach to the file
   *
   * @param file
   * @param workbookCapture
   */
  async createWorkbook(file, workbookCapture) {
    const workbookConfig = this.getWorkbookConfig(
      file.name,
      this.event.context.spaceId,
      this.event.context.environmentId,
      workbookCapture
    );
    try {
      const workbook = await this.api.workbooks.create(workbookConfig);
      if (!workbook || !workbook.data) {
        throw new Error(
          `Unable to create workbook: ${JSON.stringify(workbook)}`
        );
      }
      await this.api.files.update(file.id, { workbookId: workbook.data?.id });
      return workbook.data;
    } catch (e) {
      console.log(`error ${e}`);
      throw e;
    }
  }
  /**
   * Convert the data from each sheet into created records
   *
   * @todo some verification that rows can't contain non-header data
   * @param sheet
   * @private
   */
  makeAPIRecords(sheet) {
    return sheet.data.map((row) => {
      return (0, import_remeda.mapValues)(row, (value) => ({ value }));
    });
  }
  /**
   * Get a workbook configuration to post to the API
   *
   * @param name
   * @param spaceId
   * @param environmentId
   * @param workbookCapture
   * @private
   */
  getWorkbookConfig(name, spaceId, environmentId, workbookCapture) {
    const sheets = Object.values(
      (0, import_remeda.mapValues)(workbookCapture, (sheet, sheetName) => {
        return this.getSheetConfig(sheetName, sheet);
      })
    );
    return {
      name: `[file] ${name}`,
      labels: ["file"],
      spaceId,
      environmentId,
      sheets
    };
  }
  /**
   * Construct a sheet configuration for the extracted sheet
   *
   * @param name
   * @param headers
   * @param required
   * @param descriptions
   * @private
   */
  getSheetConfig(name, { headers, required, descriptions }) {
    return {
      name,
      fields: headers.map((key) => ({
        key,
        label: key,
        description: descriptions?.[key] || "",
        type: "string",
        constraints: required?.[key] ? [{ type: "required" }] : []
      }))
    };
  }
};

// src/excel.extractor.ts
var ExcelExtractor = class extends AbstractExtractor {
  constructor(event, options) {
    super(event);
    this.event = event;
    this.options = options;
    this._options = { rawNumbers: false, ...options };
  }
  /**
   * Parse a file buffer into a captured sheet
   *
   * @param buffer
   */
  parseBuffer(buffer) {
    const workbook = XLSX.read(buffer, {
      type: "buffer",
      cellDates: true
    });
    return (0, import_remeda2.mapValues)(workbook.Sheets, (value, key) => {
      return this.convertSheet(value);
    });
  }
  /**
   * Convert a template sheet using a special template format
   *
   * @param sheet
   */
  convertSheet(sheet) {
    let rows = XLSX.utils.sheet_to_json(sheet, {
      header: "A",
      defval: null,
      rawNumbers: this._options.rawNumbers || false
    });
    const hasHeader = this.isHeaderCandidate(rows[0]);
    const colMap = hasHeader ? rows.shift() : null;
    if (colMap) {
      const headers = (0, import_remeda2.mapValues)(colMap, (val) => val?.replace("*", ""));
      const required = (0, import_remeda2.mapValues)(colMap, (val) => val?.includes("*"));
      const data = rows.map((row) => (0, import_remeda2.mapKeys)(row, (key) => headers[key]));
      return {
        headers: Object.values(headers).filter((v) => v),
        required: (0, import_remeda2.mapKeys)(required, (k) => headers[k]),
        data
      };
    } else {
      return { headers: Object.keys(rows[0]), data: rows };
    }
  }
  /**
   * Extract the data from an uploaded XLSX file
   */
  async runExtraction() {
    try {
      const { data: file } = await this.api.files.get(this.fileId);
      if (file.ext !== "xlsx") {
        return false;
      }
      const job = await this.startJob();
      const buffer = await this.getFileBufferFromApi();
      const capture = this.parseBuffer(buffer);
      const workbook = await this.createWorkbook(file, capture);
      if (!workbook?.sheets)
        return false;
      for (const sheet of workbook.sheets) {
        if (!capture[sheet.name]) {
          continue;
        }
        const recordsData = this.makeAPIRecords(capture[sheet.name]);
        await this.api.records.insert(sheet.id, recordsData);
      }
      await this.completeJob(job);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * This needs to be improved but right now it looks for a pattern unlikely
   * to be in a header.
   *
   * Yes header | foo | bar | baz |
   * No header  | 99  | asd | 0   |
   *
   * @param header
   */
  isHeaderCandidate(header) {
    if (!header) {
      return false;
    }
    return !Object.values(header).some(
      (v) => typeof v === "string" ? /^[0-9]+$/.test(v) : !!v
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExcelExtractor
});
