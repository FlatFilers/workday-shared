"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/ansi-colors/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/ansi-colors/symbols.js"(exports, module2) {
    "use strict";
    var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
    var isWindows = typeof process !== "undefined" && process.platform === "win32";
    var isLinux = typeof process !== "undefined" && process.platform === "linux";
    var common = {
      ballotDisabled: "\u2612",
      ballotOff: "\u2610",
      ballotOn: "\u2611",
      bullet: "\u2022",
      bulletWhite: "\u25E6",
      fullBlock: "\u2588",
      heart: "\u2764",
      identicalTo: "\u2261",
      line: "\u2500",
      mark: "\u203B",
      middot: "\xB7",
      minus: "\uFF0D",
      multiplication: "\xD7",
      obelus: "\xF7",
      pencilDownRight: "\u270E",
      pencilRight: "\u270F",
      pencilUpRight: "\u2710",
      percent: "%",
      pilcrow2: "\u2761",
      pilcrow: "\xB6",
      plusMinus: "\xB1",
      question: "?",
      section: "\xA7",
      starsOff: "\u2606",
      starsOn: "\u2605",
      upDownArrow: "\u2195"
    };
    var windows = Object.assign({}, common, {
      check: "\u221A",
      cross: "\xD7",
      ellipsisLarge: "...",
      ellipsis: "...",
      info: "i",
      questionSmall: "?",
      pointer: ">",
      pointerSmall: "\xBB",
      radioOff: "( )",
      radioOn: "(*)",
      warning: "\u203C"
    });
    var other = Object.assign({}, common, {
      ballotCross: "\u2718",
      check: "\u2714",
      cross: "\u2716",
      ellipsisLarge: "\u22EF",
      ellipsis: "\u2026",
      info: "\u2139",
      questionFull: "\uFF1F",
      questionSmall: "\uFE56",
      pointer: isLinux ? "\u25B8" : "\u276F",
      pointerSmall: isLinux ? "\u2023" : "\u203A",
      radioOff: "\u25EF",
      radioOn: "\u25C9",
      warning: "\u26A0"
    });
    module2.exports = isWindows && !isHyper ? windows : other;
    Reflect.defineProperty(module2.exports, "common", { enumerable: false, value: common });
    Reflect.defineProperty(module2.exports, "windows", { enumerable: false, value: windows });
    Reflect.defineProperty(module2.exports, "other", { enumerable: false, value: other });
  }
});

// ../../node_modules/ansi-colors/index.js
var require_ansi_colors = __commonJS({
  "../../node_modules/ansi-colors/index.js"(exports, module2) {
    "use strict";
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
    var hasColor = () => {
      if (typeof process !== "undefined") {
        return process.env.FORCE_COLOR !== "0";
      }
      return false;
    };
    var create = () => {
      const colors = {
        enabled: hasColor(),
        visible: true,
        styles: {},
        keys: {}
      };
      const ansi = (style2) => {
        let open = style2.open = `\x1B[${style2.codes[0]}m`;
        let close = style2.close = `\x1B[${style2.codes[1]}m`;
        let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
        style2.wrap = (input, newline) => {
          if (input.includes(close))
            input = input.replace(regex, close + open);
          let output = open + input + close;
          return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
        };
        return style2;
      };
      const wrap = (style2, input, newline) => {
        return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
      };
      const style = (input, stack) => {
        if (input === "" || input == null)
          return "";
        if (colors.enabled === false)
          return input;
        if (colors.visible === false)
          return "";
        let str = "" + input;
        let nl = str.includes("\n");
        let n = stack.length;
        if (n > 0 && stack.includes("unstyle")) {
          stack = [.../* @__PURE__ */ new Set(["unstyle", ...stack])].reverse();
        }
        while (n-- > 0)
          str = wrap(colors.styles[stack[n]], str, nl);
        return str;
      };
      const define = (name, codes, type) => {
        colors.styles[name] = ansi({ name, codes });
        let keys = colors.keys[type] || (colors.keys[type] = []);
        keys.push(name);
        Reflect.defineProperty(colors, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors.alias(name, value);
          },
          get() {
            let color = (input) => style(input, color.stack);
            Reflect.setPrototypeOf(color, colors);
            color.stack = this.stack ? this.stack.concat(name) : [name];
            return color;
          }
        });
      };
      define("reset", [0, 0], "modifier");
      define("bold", [1, 22], "modifier");
      define("dim", [2, 22], "modifier");
      define("italic", [3, 23], "modifier");
      define("underline", [4, 24], "modifier");
      define("inverse", [7, 27], "modifier");
      define("hidden", [8, 28], "modifier");
      define("strikethrough", [9, 29], "modifier");
      define("black", [30, 39], "color");
      define("red", [31, 39], "color");
      define("green", [32, 39], "color");
      define("yellow", [33, 39], "color");
      define("blue", [34, 39], "color");
      define("magenta", [35, 39], "color");
      define("cyan", [36, 39], "color");
      define("white", [37, 39], "color");
      define("gray", [90, 39], "color");
      define("grey", [90, 39], "color");
      define("bgBlack", [40, 49], "bg");
      define("bgRed", [41, 49], "bg");
      define("bgGreen", [42, 49], "bg");
      define("bgYellow", [43, 49], "bg");
      define("bgBlue", [44, 49], "bg");
      define("bgMagenta", [45, 49], "bg");
      define("bgCyan", [46, 49], "bg");
      define("bgWhite", [47, 49], "bg");
      define("blackBright", [90, 39], "bright");
      define("redBright", [91, 39], "bright");
      define("greenBright", [92, 39], "bright");
      define("yellowBright", [93, 39], "bright");
      define("blueBright", [94, 39], "bright");
      define("magentaBright", [95, 39], "bright");
      define("cyanBright", [96, 39], "bright");
      define("whiteBright", [97, 39], "bright");
      define("bgBlackBright", [100, 49], "bgBright");
      define("bgRedBright", [101, 49], "bgBright");
      define("bgGreenBright", [102, 49], "bgBright");
      define("bgYellowBright", [103, 49], "bgBright");
      define("bgBlueBright", [104, 49], "bgBright");
      define("bgMagentaBright", [105, 49], "bgBright");
      define("bgCyanBright", [106, 49], "bgBright");
      define("bgWhiteBright", [107, 49], "bgBright");
      colors.ansiRegex = ANSI_REGEX;
      colors.hasColor = colors.hasAnsi = (str) => {
        colors.ansiRegex.lastIndex = 0;
        return typeof str === "string" && str !== "" && colors.ansiRegex.test(str);
      };
      colors.alias = (name, color) => {
        let fn = typeof color === "string" ? colors[color] : color;
        if (typeof fn !== "function") {
          throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
        }
        if (!fn.stack) {
          Reflect.defineProperty(fn, "name", { value: name });
          colors.styles[name] = fn;
          fn.stack = [name];
        }
        Reflect.defineProperty(colors, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors.alias(name, value);
          },
          get() {
            let color2 = (input) => style(input, color2.stack);
            Reflect.setPrototypeOf(color2, colors);
            color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
            return color2;
          }
        });
      };
      colors.theme = (custom) => {
        if (!isObject(custom))
          throw new TypeError("Expected theme to be an object");
        for (let name of Object.keys(custom)) {
          colors.alias(name, custom[name]);
        }
        return colors;
      };
      colors.alias("unstyle", (str) => {
        if (typeof str === "string" && str !== "") {
          colors.ansiRegex.lastIndex = 0;
          return str.replace(colors.ansiRegex, "");
        }
        return "";
      });
      colors.alias("noop", (str) => str);
      colors.none = colors.clear = colors.noop;
      colors.stripColor = colors.unstyle;
      colors.symbols = require_symbols();
      colors.define = define;
      return colors;
    };
    module2.exports = create();
    module2.exports.create = create;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AuthenticatedClient: () => AuthenticatedClient,
  Browser: () => Browser,
  Client: () => Client,
  EventHandler: () => EventHandler,
  FlatfileEvent: () => FlatfileEvent,
  FlatfileListener: () => FlatfileListener,
  FlatfileVirtualMachine: () => FlatfileVirtualMachine,
  PollingEventDriver: () => PollingEventDriver
});
module.exports = __toCommonJS(src_exports);

// src/events/authenticated.client.ts
var import_api = require("@flatfile/api");
var import_node_fetch = __toESM(require("node-fetch"));
var FLATFILE_API_URL = process.env.AGENT_INTERNAL_URL || "http://localhost:3000";
var AuthenticatedClient = class {
  constructor(accessToken, apiUrl) {
    this._accessToken = accessToken || process.env.FLATFILE_BEARER_TOKEN || "...";
    this._apiUrl = apiUrl || FLATFILE_API_URL;
  }
  get api() {
    if (this._api) {
      return this._api;
    }
    const accessToken = this._accessToken;
    const apiUrl = this._apiUrl;
    const ClientConfig = new import_api.Configuration({
      basePath: `${apiUrl}/v1`,
      fetchApi: import_node_fetch.default,
      accessToken,
      headers: {
        Authorization: `Bearer ${accessToken || "..."}`,
        "x-disable-hooks": "true"
      }
    });
    this._api = new import_api.DefaultApi(ClientConfig);
    return this._api;
  }
  fetch(url) {
    if (this._fetchApi) {
      return this._fetchApi;
    }
    const headers = {
      Authorization: `Bearer ${this._accessToken}`,
      "x-disable-hooks": "true"
    };
    const fetchUrl = this._apiUrl + "/" + url;
    this._fetchApi = (0, import_node_fetch.default)(fetchUrl, {
      headers
    }).then((resp) => resp.json()).then((resp) => resp.data);
    return this._fetchApi;
  }
  setVariables({
    accessToken,
    apiUrl,
    fetchApi
  }) {
    this._accessToken = accessToken;
    this._apiUrl = apiUrl;
    this.fetchApi = fetchApi;
  }
};

// src/events/cache.ts
var EventCache = class {
  constructor() {
    this.eventCache = /* @__PURE__ */ new Map();
  }
  async init(key, callback) {
    if (this.eventCache.get(key)) {
      console.log(`Cache hit for ${key}`);
      return this.eventCache.get(key);
    } else {
      console.log(`no cache hit for ${key}`);
      const result = await callback();
      this.eventCache.set(key, result);
      return result;
    }
  }
  async set(key, callback) {
    if (this.eventCache.get(key)) {
      console.log(`cache set for ${key}`);
      const result = await callback();
      this.eventCache.set(key, result);
      return result;
    } else {
      throw new Error("Cache key not found");
    }
  }
  get(key) {
    if (this.eventCache.get(key)) {
      return this.eventCache.get(key);
    } else {
      throw new Error("Cache key not found");
    }
  }
  delete(key) {
    if (!key) {
      this.eventCache.clear();
    } else if (this.eventCache.get(key)) {
      if (Array.isArray(key)) {
        key.forEach((k) => this.eventCache.delete(k));
      } else {
        this.eventCache.delete(key);
      }
    } else {
      throw new Error("Cache key not found");
    }
  }
};

// src/events/flatfile.event.ts
var FlatfileEvent = class extends AuthenticatedClient {
  constructor(src, accessToken, apiUrl) {
    super(accessToken, apiUrl);
    this.src = src;
    this.afterAllCallbacks = /* @__PURE__ */ new Map();
    this.cache = new EventCache();
    this.domain = src.domain;
    this.topic = src.topic;
    this.context = src.context;
    this.payload = src.payload;
    this.target = src.target || "";
    this.action = src.context?.actionName || "";
  }
  /**
   * Should return either event body if expanded already or fetch data from the
   * signed callback URL
   *
   * @todo this should work with the included callback URL
   */
  get data() {
    if (this.src.dataUrl) {
      return this.fetch(this.src.dataUrl);
    } else {
      return this.payload;
    }
  }
  afterAll(callback, cacheKey) {
    const key = cacheKey || callback.toString();
    if (!this.afterAllCallbacks.get(key)) {
      this.afterAllCallbacks.set(key, callback);
    }
  }
};

// ../../node_modules/wildcard-match/build/index.es.mjs
function escapeRegExpChar(char) {
  if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") {
    return "\\" + char;
  } else {
    return char;
  }
}
function escapeRegExpString(str) {
  var result = "";
  for (var i = 0; i < str.length; i++) {
    result += escapeRegExpChar(str[i]);
  }
  return result;
}
function transform(pattern, separator) {
  if (separator === void 0) {
    separator = true;
  }
  if (Array.isArray(pattern)) {
    var regExpPatterns = pattern.map(function(p) {
      return "^" + transform(p, separator) + "$";
    });
    return "(?:" + regExpPatterns.join("|") + ")";
  }
  var separatorSplitter = "";
  var separatorMatcher = "";
  var wildcard = ".";
  if (separator === true) {
    separatorSplitter = "/";
    separatorMatcher = "[/\\\\]";
    wildcard = "[^/\\\\]";
  } else if (separator) {
    separatorSplitter = separator;
    separatorMatcher = escapeRegExpString(separatorSplitter);
    if (separatorMatcher.length > 1) {
      separatorMatcher = "(?:" + separatorMatcher + ")";
      wildcard = "((?!" + separatorMatcher + ").)";
    } else {
      wildcard = "[^" + separatorMatcher + "]";
    }
  }
  var requiredSeparator = separator ? separatorMatcher + "+?" : "";
  var optionalSeparator = separator ? separatorMatcher + "*?" : "";
  var segments = separator ? pattern.split(separatorSplitter) : [pattern];
  var result = "";
  for (var s = 0; s < segments.length; s++) {
    var segment = segments[s];
    var nextSegment = segments[s + 1];
    var currentSeparator = "";
    if (!segment && s > 0) {
      continue;
    }
    if (separator) {
      if (s === segments.length - 1) {
        currentSeparator = optionalSeparator;
      } else if (nextSegment !== "**") {
        currentSeparator = requiredSeparator;
      } else {
        currentSeparator = "";
      }
    }
    if (separator && segment === "**") {
      if (currentSeparator) {
        result += s === 0 ? "" : currentSeparator;
        result += "(?:" + wildcard + "*?" + currentSeparator + ")*?";
      }
      continue;
    }
    for (var c2 = 0; c2 < segment.length; c2++) {
      var char = segment[c2];
      if (char === "\\") {
        if (c2 < segment.length - 1) {
          result += escapeRegExpChar(segment[c2 + 1]);
          c2++;
        }
      } else if (char === "?") {
        result += wildcard;
      } else if (char === "*") {
        result += wildcard + "*?";
      } else {
        result += escapeRegExpChar(char);
      }
    }
    result += currentSeparator;
  }
  return result;
}
function isMatch(regexp, sample) {
  if (typeof sample !== "string") {
    throw new TypeError("Sample must be a string, but " + typeof sample + " given");
  }
  return regexp.test(sample);
}
function wildcardMatch(pattern, options) {
  if (typeof pattern !== "string" && !Array.isArray(pattern)) {
    throw new TypeError("The first argument must be a single pattern string or an array of patterns, but " + typeof pattern + " given");
  }
  if (typeof options === "string" || typeof options === "boolean") {
    options = { separator: options };
  }
  if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) {
    throw new TypeError("The second argument must be an options object or a string/boolean separator, but " + typeof options + " given");
  }
  options = options || {};
  if (options.separator === "\\") {
    throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
  }
  var regexpPattern = transform(pattern, options.separator);
  var regexp = new RegExp("^" + regexpPattern + "$", options.flags);
  var fn = isMatch.bind(null, regexp);
  fn.options = options;
  fn.pattern = pattern;
  fn.regexp = regexp;
  return fn;
}
var index_es_default = wildcardMatch;

// src/events/glob.match.ts
var import_flat = __toESM(require("flat"));
function glob(val, filter) {
  if (!val || typeof val !== "string") {
    return false;
  }
  return index_es_default(filter || "**", ":")(val);
}
function objectMatches(object, filterObject) {
  const cleanFilter = !filterObject || typeof filterObject !== "object" ? { "**": filterObject } : filterObject;
  if (typeof object !== "object") {
    throw new Error("You cannot filter a non-object");
  }
  let denied = false;
  const filter = (0, import_flat.default)(cleanFilter, { safe: true });
  const flattened = (0, import_flat.default)(object, { safe: true });
  for (const keyPattern in filter) {
    const keys = filterKeys(flattened, keyPattern);
    const valuePattern = Array.isArray(filter[keyPattern]) ? filter[keyPattern] : [filter[keyPattern]];
    denied || (denied = !keys.some((key) => {
      const value = flattened[key];
      return valuePattern.some((match) => globOrMatch(value, match));
    }));
  }
  return !denied;
}
function filterKeys(object, glob2) {
  glob2 = glob2.includes("*") || glob2.includes(".") ? glob2 : `**.${glob2}`;
  const matcher = index_es_default(glob2, ".");
  return Object.keys(object).filter((key) => matcher(key));
}
function globOrMatch(val, filter) {
  if (val === void 0 || val === null) {
    return filter === null;
  }
  if (Array.isArray(val)) {
    return val.some((v) => globOrMatch(v, filter));
  }
  if (typeof filter === "string") {
    return glob(val.toString(), filter);
  }
  return val === filter;
}

// src/events/event.handler.ts
var EventHandler = class extends AuthenticatedClient {
  constructor(filter, accessToken, apiUrl) {
    super(accessToken, apiUrl);
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    this.listeners = [];
    /**
     * Cache of registered child nodes for this listener. These nodes will
     * only receive events that pass the parent filter.
     *
     * @private
     */
    this.nodes = [];
    if (filter) {
      this.filterQuery = filter;
    }
  }
  on(query, ...rest) {
    let filter = {};
    const callback = rest.pop();
    if (rest.length) {
      filter = rest.shift();
    }
    this.listeners.push([query, filter, callback]);
    return this;
  }
  /**
   * Add child nodes to send this event to as well
   *
   * @param node
   */
  addNode(node) {
    this.nodes.push(node);
    return this;
  }
  /**
   * Dispatch an event and resolve the promise once it has completed (or
   * errored
   *
   * @todo - is there a right order in which to resolve event listeners?
   *   Should it matter?
   *
   * @param event
   */
  async dispatchEvent(event) {
    if (!(event instanceof FlatfileEvent)) {
      event = new FlatfileEvent(event, this._accessToken, this._apiUrl);
      if (this._apiUrl && this._accessToken) {
        event.setVariables({
          apiUrl: this._apiUrl,
          accessToken: this._accessToken
        });
      }
    }
    if (!this.matchEvent(event, this.filterQuery)) {
      return;
    }
    await this.trigger(event);
    for (const node of this.nodes) {
      await node.dispatchEvent(event);
    }
    await event.afterAllCallbacks.forEach(async (cb) => cb(event));
    event.cache.delete();
  }
  /**
   * @deprecated legacy shim for receiving events from the VM layer
   * @alias dispatchEvent
   * @param event
   */
  async routeEvent(event) {
    return this.dispatchEvent(event);
  }
  /**
   * Actually trigger the event listeners on this particular target
   *
   * @note It is safer for now to run this in series to avoid IO locks and
   *       potential race conditions and uncaught errors
   *
   * @param event
   */
  async trigger(event) {
    const listeners = this.getListeners(event);
    for (const cb of listeners) {
      await cb(event);
    }
  }
  /**
   * Get any listeners from this target subscribing to this event
   *
   * @param event
   */
  getListeners(event) {
    return this.listeners.filter(([query, filter]) => {
      const globbed = glob(event.topic, query);
      const matched = this.matchEvent(event, filter);
      return globbed && matched;
    }).map(([_q, _ctx, cb]) => cb);
  }
  /**
   * Attach more event listeners using a callback function. Used most
   * frequently for plugins.
   *
   * @param fn
   */
  use(fn) {
    fn(this);
    return this;
  }
  /**
   * Filter an event out based on glob filter object
   *
   * @param event
   * @param filter
   */
  matchEvent(event, filter) {
    return filter ? objectMatches(event, filter) : true;
  }
};

// src/flatfile.listener.ts
var FlatfileListener = class extends EventHandler {
  /**
   * Subscribe to events only within a certain namespace.
   *
   * @param namespace
   * @param cb
   */
  namespace(namespace, cb) {
    return this.filter({ namespace }, cb);
  }
  /**
   * Filter by namespace
   *
   * @param filter
   * @param cb
   */
  filter(filter, cb) {
    const client = new FlatfileListener(filter);
    this.addNode(client);
    cb?.(client);
    return client;
  }
  /**
   * Start subscribing to events
   *
   * @param cb
   */
  static create(cb) {
    const client = new FlatfileListener();
    cb(client);
    return client;
  }
  /**
   * Mount this client using an acceptable Event Driver
   */
  mount(driver) {
    driver.mountEventHandler(this);
    return this;
  }
};

// src/event-drivers/_EventDriver.ts
var EventDriver = class {
  get handler() {
    if (!this._handler) {
      throw new Error("handler not registered yet");
    }
    return this._handler;
  }
  /**
   * Mount an event handler
   *
   * @param handler
   */
  mountEventHandler(handler) {
    this._handler = handler;
    return this;
  }
  /**
   * Dispatch an event
   *
   * @param e
   */
  dispatchEvent(e) {
    this.handler.dispatchEvent(e);
    return this;
  }
};

// src/event-drivers/Browser.ts
var Browser = class extends EventDriver {
  constructor({
    apiUrl,
    accessToken,
    environmentId,
    fetchApi
  }) {
    super();
    this._apiUrl = apiUrl;
    this._accessToken = accessToken;
    this._environmentId = environmentId || "";
    this._fetchApi = fetchApi || void 0;
  }
  mountEventHandler(handler) {
    handler.setVariables({
      accessToken: this._accessToken,
      apiUrl: this._apiUrl,
      fetchApi: this._fetchApi
    });
    this._handler = handler;
    return this;
  }
};

// src/event-drivers/Polling.ts
var import_ansi_colors = __toESM(require_ansi_colors());
var events = /* @__PURE__ */ new Map();
var PollingEventDriver = class extends EventDriver {
  constructor({
    environmentId,
    apiUrl,
    accessToken
  }) {
    super();
    this.apiUrl = apiUrl || process.env.AGENT_INTERNAL_URL || "https://platform.flatfile.com/api/";
    this.accessToken = accessToken || process.env.FLATFILE_API_KEY || process.env.FLATFILE_BEARER_TOKEN || "...";
    this.environmentId = environmentId || process.env.FLATFILE_ENVIRONMENT_ID;
  }
  start() {
    this.handler.setVariables({
      accessToken: this.accessToken,
      apiUrl: this.apiUrl
    });
    let lastTimestamp = new Date(Date.now() - 5e3);
    if (!this.environmentId) {
      throw new Error("environmentId is required");
    }
    setInterval(() => {
      this.handler.api.getEvents({
        since: lastTimestamp,
        includeAcknowledged: false,
        environmentId: this.environmentId
      }).then((res) => {
        process.stdout.cursorTo(0);
        process.stdout.clearLine(1);
        if (!res.data?.length) {
          process.stdout.write(
            `${import_ansi_colors.default.white.bgMagentaBright(
              "listening for events"
            )} at ${lastTimestamp.toLocaleString()}`
          );
        }
        res.data?.forEach((e) => {
          if (!events.get(e.id)) {
            process.stdout.write(
              `${import_ansi_colors.default.white.bgBlue(e.topic)} ${import_ansi_colors.default.white.bgYellow(
                e.id
              )} ${e.createdAt?.toLocaleString()}
`
            );
            events.set(e.id, true);
            this.dispatchEvent(e);
          }
        });
      }).catch(console.error);
      lastTimestamp = new Date(Date.now() - 5e3);
    }, 500);
  }
  shutdown() {
  }
};

// src/event-drivers/FlatfileVirtualMachine.ts
var FlatfileVirtualMachine = class extends EventDriver {
  /**
   * This method is triggered from within the Flatfile Core VM Runner. This
   * EventDriver does not have to listen for events because this method will
   * be invoked as necessary.
   *
   * @param event
   */
  handle(event) {
    this.dispatchEvent(event);
  }
  mountEventHandler(handler) {
    this._handler = handler;
    return this;
  }
};

// src/index.ts
var Client = class extends FlatfileListener {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthenticatedClient,
  Browser,
  Client,
  EventHandler,
  FlatfileEvent,
  FlatfileListener,
  FlatfileVirtualMachine,
  PollingEventDriver
});
