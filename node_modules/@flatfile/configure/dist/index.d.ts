import Blueprint, { Action as Action$1, SheetAccess, SheetConfig } from '@flatfile/blueprint';
import { DefaultApi, Event, RecordWithLinks, Record as Record$1, SpaceAccess, Blueprint as Blueprint$1 } from '@flatfile/api';
import { RequestInit } from 'node-fetch';
import * as _flatfile_hooks from '@flatfile/hooks';
import { FlatfileRecords as FlatfileRecords$1, FlatfileSession, FlatfileRecord as FlatfileRecord$1, TPrimitive, TRecordData, IRecordInfo } from '@flatfile/hooks';
import * as _flatfile_schema from '@flatfile/schema';
import { SchemaILFieldArgs, SchemaILField, SchemaILModel, IJsonSchema, BaseSchemaILFieldArgs } from '@flatfile/schema';
import _ from 'lodash';
import { FlatfileRecord, FlatfileRecords } from '@flatfile/hooks/';

declare class AuthenticatedClient {
    private _api?;
    get api(): DefaultApi;
    private _fetch?;
    fetch(url: string, options?: RequestInit): Promise<any>;
}

type GetDataOptions = {
    [key: string]: any;
};
interface GetData extends Function {
    (options?: GetDataOptions): Promise<any>;
    then<TResult1 = any, TResult2 = any>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
}
declare class FlatfileEvent extends AuthenticatedClient {
    readonly src: Event;
    /**
     * Event ID from the API
     *
     * @example us0_ev_82hgidh9skd
     * @readonly
     *
     */
    readonly id?: string;
    /**
     * Topic the event was produced on
     *
     * @example workbook:created
     * @readonly
     */
    readonly topic?: string;
    readonly name: string;
    readonly domain: string;
    readonly target: string;
    readonly context: any;
    readonly body: any;
    readonly action?: string;
    /**
     * Fetch record data from Flatfile API via the event's dataUrl
     *
     * @async
     * @param {object} options
     * @returns {Promise<any>} JSON
     */
    data: GetData;
    /**
     * Target entity id
     *
     * @example us0_wb_82hgidh9skd
     */
    constructor(src: Event);
    /**
     * Should return either event body if expanded already or fetch data from the
     * signed dataURL
     */
    private fetchData;
    /**
     * Fetch the actual body of each context item referenced
     * @param _contexts
     * @todo later
     */
    expand(..._contexts: string[]): void;
    ack(_progress?: number): void;
}
type EventCallback = (evt: FlatfileEvent) => void;

declare class Action {
    readonly nameOrOptions: string | Action$1;
    readonly handler: (event: FlatfileEvent, options: Action$1) => void;
    readonly slug?: string;
    readonly label: string;
    readonly options: Action$1;
    constructor(nameOrOptions: string | Action$1, handler: (event: FlatfileEvent, options: Action$1) => void);
}

declare class EventHandler extends AuthenticatedClient {
    /**
     * Event target name, defaults to all events
     */
    readonly targetName: string;
    slug?: string;
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    private eventListeners;
    /**
     * Cache of registered child nodes for this listener
     * @private
     */
    private childNodes;
    /**
     * Register a subscriber for events that match this path
     *
     * @param listenerQuery any event name or grep pattern
     */
    on(listenerQuery: string | string[], callback: EventCallback): this;
    /**
     * Register a subscriber for events that match this path
     *
     * @param eventlistener any event name or grep pattern
     */
    addEventListener(listenerQuery: string | string[], callback: EventCallback): this;
    /**
     * Add child nodes to send this event to as well
     *
     * @param children
     */
    addNode(node: EventHandler, slug?: string): void;
    /**
     * Register a bulk set of listeners instead
     *
     * @param listeners
     */
    registerListeners(listeners: Record<string, EventCallback>): void;
    /**
     * Emit an event and resolve the promise once it has completed (or errored
     * @param event
     */
    emit(event: FlatfileEvent): Promise<void>;
    /**
     * Actually trigger the event listeners on this particular target
     *
     * @note It is safer for now to run this in series to avoid IO locks and
     *       potential race conditions and uncaught errors
     *
     * @param event
     */
    trigger(event: FlatfileEvent): Promise<void>;
    /**
     * Get any listeners from this target subscribing to this event
     *
     * @param event
     */
    getListeners(event: FlatfileEvent): EventCallback[];
    /**
     * Implement a function that returns a target name compatible with the event
     * routing system
     *
     * @param slug A context-defined slug (allows the same entity to be used in
     *             multiple contexts)
     */
    getEventTargetName(slug?: string): string;
    /**
     * Traverse through entire target tree and find the target node to emit from
     *
     * @param target
     * @param slug
     */
    findTargetNode(event: FlatfileEvent, slug?: string): EventHandler | undefined;
    routeEvent(event: Event): Promise<void>;
}

declare class Role extends EventHandler implements RoleOptions {
    /**
     * User-friendly group name
     *
     * @example Administrators
     */
    readonly name: string;
    /**
     * User facing description
     */
    readonly description?: string;
    constructor({ name, description }: RoleOptions);
    getEventTargetName(slug: string): string;
}
interface RoleOptions {
    name: string;
    description?: string;
}

type TRecordStageLevel = 'cast' | 'required' | 'compute' | 'validate' | 'apply' | 'other';
type TRecordLevel = 'error' | 'warn' | 'info';
declare class Value<T> {
    readonly value: T;
    readonly meta: Record<any, any>;
    constructor(value: T, meta: Record<any, any>);
}
declare class Message {
    readonly message: string;
    readonly level: TRecordLevel;
    readonly stage: TRecordStageLevel;
    constructor(message: string, level: TRecordLevel, stage: TRecordStageLevel);
}
type Dirty<T> = string | null | T;
type Nullable<T> = null | T;
type Waitable<T> = T;
type Writable<T> = Waitable<T | Value<T>>;
interface IFieldHooks<T> {
    cast: (value: Dirty<T>) => Nullable<T>;
    default: Nullable<T>;
    compute: (value: T) => T;
    validate: (value: T) => void | Message[];
    egressFormat: ((value: T) => string) | false;
}
interface IExtraFieldOptions {
    allowDataLoss?: boolean;
}
type AnyField = Field<any>;
declare const FieldHookDefaults: <T>() => IFieldHooks<T>;
declare const wrapValidate: <T>(valFunc: (value: T) => void | Message[]) => (value: T) => Message[];
declare const verifyEgressCycle: <T>(field: Field<T, {}>, castVal: T) => boolean;
type FieldOnlyOptions<T> = SchemaILFieldArgs & IFieldHooks<T> & IExtraFieldOptions;
declare class Field<T, Unused extends Record<string, any> = {}> {
    options: FieldOnlyOptions<T>;
    constructor(options: FieldOnlyOptions<T>);
    extraFieldsToAdd: Record<string, AnyField>;
    toCastDefault(rawValue: any): [Nullable<T>, Message[]];
    computeFromValue(reallyActuallyCast: T, rawValue: any): [Nullable<T>, Message[]];
    computeToValue(rawValue: any): [Nullable<T>, Message[]];
    validate(val: T): void | Message[];
    getValue(rawValue: Dirty<T>): Nullable<T>;
    getMessages(rawValue: Nullable<T>): Message[];
    toSchemaILField(fieldName: string, namespace?: string): SchemaILField;
    contributeToSchemaILFBase(): void;
}

/**
 * Anything implementing this can be exported directly as a Flatfile X
 * agent. This is a convenience method so that you don't have to export the
 * full FlatfileConfig > SpaceConfig > WorkbookConfig > SheetConfig if you
 * only have one of these.
 */
interface Mountable {
    /**
     * Generate and return a default FlatfileConfig stack.
     */
    mount(): Agent;
}

declare class RecordTranslater<T extends FlatfileRecord | RecordWithLinks> {
    private readonly records;
    constructor(records: T[]);
    toFlatFileRecords: () => FlatfileRecords<any>;
    toXRecords: () => {
        id: string;
        values: any;
        metadata: Object | undefined;
    }[] | Record$1[];
}

type RecordsComputeType = (records: FlatfileRecords$1<any>, session?: FlatfileSession, logger?: any) => Promise<void>;
type RecordCompute = {
    dependsOn?: string[];
    uses?: string[];
    modifies?: string[];
    (record: FlatfileRecord$1<any>, session: FlatfileSession, logger?: any): void;
};
declare class UniqueAndRequiredPlugin {
    run(fields: FieldConfig, records: FlatfileRecord$1<any>[]): void;
}
interface SheetOptions<FC> {
    allowCustomFields: boolean;
    readonly: boolean;
    access: SheetAccess[];
    recordCompute: RecordCompute;
    batchRecordsCompute: RecordsComputeType;
    previewFieldKey?: string;
    actions?: List<Action>;
}
declare class Sheet<FC extends FieldConfig> extends EventHandler implements Mountable {
    name: string;
    fields: FieldConfig;
    passedOptions?: Partial<SheetOptions<FC>> | undefined;
    targetName: string;
    options: SheetOptions<FC>;
    private contributedRecordFuncs;
    private sheetCompute;
    idFromAPI: string | undefined;
    constructor(name: string, fields: FieldConfig, passedOptions?: Partial<SheetOptions<FC>> | undefined);
    runProcess(records: FlatfileRecords$1<any>, session: FlatfileSession, logger: any): Promise<FlatfileRecords$1<any>>;
    registerActions(): void;
    toSchemaIL(namespace: string, slug: string): SchemaILModel;
    toJSONSchema(namespace: string, slug: string): IJsonSchema;
    mount(): Agent;
    /**
     * Shim the current hook evaluation system into the new X event routing engine
     *
     * @param e
     */
    recordsChangedEventShim(e: FlatfileEvent): Promise<void>;
    prepareXRecords(records: any): Promise<FlatfileRecords$1<any>>;
    toBlueprint(namespace: string, slug: string): SheetConfig;
    getSheetCompute(): object | undefined;
}
type FieldConfig = Record<string, AnyField>;

interface PortalOption {
    name: string;
    sheet: string;
    archived?: boolean;
    helpContent?: string;
}
declare class Portal {
    readonly options: PortalOption;
    privateKeyString: string | undefined;
    id: string | undefined;
    constructor(options: PortalOption);
    setId(id: string): void;
    setPrivateKeyString(privateKeyString: string): void;
}

declare class Workbook extends EventHandler implements Mountable {
    readonly options: IWorkbookOptions;
    targetName: string;
    constructor(options: Partial<IWorkbookOptions>);
    /**
     * Return a default FlatfileConfig if this mounted directly
     */
    mount(): Agent;
    getEventTargetName(): string;
    processRecords: (records: FlatfileRecords$1<any>, payload: IHookPayload, logger?: any) => Promise<FlatfileRecords$1<any>>;
    handleLegacyDataHook(payload: IHookPayload): Promise<_flatfile_hooks.IRawRecordWithInfo<_flatfile_hooks.TRecordDataWithLinks<_flatfile_hooks.TPrimitive>>[]>;
    runHookOnLambda: ({ recordBatch, session, logger, eventType, }: {
        recordBatch: FlatfileRecords$1<any>;
        session: FlatfileSession;
        logger: any;
        eventType?: string | undefined;
    }) => Promise<_flatfile_hooks.IRawRecordWithInfo<any>[]>;
}
interface IHookPayload {
    workspaceId: string;
    workbookId: string;
    schemaId: number;
    schemaSlug: string;
    uploads: string[];
    rows: any;
    endUser?: any;
    env?: Record<string, string | boolean | number>;
    envSignature?: string;
}
interface IWorkbookOptions {
    namespace: string;
    name: string;
    slug?: string;
    sheets: Record<string, Sheet<any>>;
    ref?: string;
    labels?: Array<string>;
    options?: {};
    portals?: Portal[];
}

/**
 * Generate a new space configuration for Flatfile. Space configurations
 * are used as a template when creating a new space as well as handle the routing
 * of events generated by Flatfile.
 */
declare class SpaceConfig extends EventHandler implements Mountable {
    readonly options: ConfigurationOptions$1;
    targetName: string;
    constructor(options: ConfigurationOptions$1);
    getEventTargetName(): string;
    /**
     * Return a default FlatfileConfig if this mounted directly
     */
    mount(): Agent;
}
type List<T> = Record<string, T>;
interface ConfigurationOptions$1 {
    name: string;
    workbookConfigs: List<Workbook>;
    slug?: string;
    description?: string;
    theme?: any;
    roles?: List<Role>;
    access?: SpaceAccess[];
}

/**
 * Generate a new space configuration for Flatfile. Space configurations
 * are used as a template when creating a new space as well as handle the routing
 * of events generated by Flatfile.
 */
declare class Agent extends EventHandler implements Mountable {
    readonly options: ConfigurationOptions;
    constructor(options: ConfigurationOptions);
    blueprints(): (typeof Blueprint)[] | undefined;
    mount(): this;
}
interface ConfigurationOptions {
    name?: string;
    description?: string;
    spaceConfigs: List<SpaceConfig>;
    blueprints?: (typeof Blueprint)[];
}

type computeType = (limitedObj: Record<string, TPrimitive>) => unknown;
interface ComputedFieldArgs {
    dependsOn: string[];
    possiblyDependsOn?: string[];
    compute: computeType;
    destination: string;
}
declare const ComputedField: (destinationField: AnyField, computeArgs: ComputedFieldArgs) => AnyField;

declare class SheetTester {
    readonly passedWorkbook: Workbook;
    readonly passedSheetName: string;
    workbook: Workbook;
    sheetName: string;
    private testSession;
    constructor(passedWorkbook: Workbook, passedSheetName: string);
    private checkRecordsForExtraFields;
    private transformRecord;
    private transformRecords;
    transformField(pkey: string, value: any, other?: {}, errOn?: string): Promise<TPrimitive | {
        value: TPrimitive;
        links: TRecordData<TPrimitive>[];
    }>;
    testRecord(record: {}): Promise<_flatfile_hooks.TRecordDataWithLinks<TPrimitive>>;
    testRecords(recordBatch: Record<string, any>[]): Promise<_flatfile_hooks.TRecordDataWithLinks<TPrimitive>[]>;
    testMessage(record: {}): Promise<IRecordInfo<_flatfile_hooks.TRecordDataWithLinks<TPrimitive>, string | number>[]>;
    testMessages(recordBatch: Record<string, any>[]): Promise<IRecordInfo<_flatfile_hooks.TRecordDataWithLinks<TPrimitive>, string | number>[][]>;
}
type InfoObj = IRecordInfo<TRecordData<TPrimitive>, string | number>;
declare const removeUndefineds: (obj: Record<string, any>) => _.Dictionary<any>;
declare const matchMessages: (messages: InfoObj[], field?: string, message?: string, level?: string) => false | any[];
declare const matchSingleMessage: (messages: InfoObj[], field?: string, message?: string, level?: string) => false | any;

declare const BooleanField: (newOptions?: string | Partial<Omit<_flatfile_schema.BaseSchemaILField, "field"> & IFieldHooks<boolean> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.SchemaILEnumField, "field"> & IFieldHooks<boolean> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.LinkedSheetField, "field"> & IFieldHooks<boolean> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.ReferenceField, "field"> & IFieldHooks<boolean> & IExtraFieldOptions>) => Field<boolean, {}>;

declare const DateField: (newOptions?: string | Partial<Omit<_flatfile_schema.BaseSchemaILField, "field"> & IFieldHooks<Date> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.SchemaILEnumField, "field"> & IFieldHooks<Date> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.LinkedSheetField, "field"> & IFieldHooks<Date> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.ReferenceField, "field"> & IFieldHooks<Date> & IExtraFieldOptions>) => Field<Date, {}>;

declare const GroupByField: (groupByField: string[], expression: any) => Field<string, {}>;

declare const LinkedField: (newOptions: Partial<FieldOnlyOptions<string>> & {
    sheet: Sheet<FieldConfig>;
    sheetName?: string | undefined;
    upsert?: boolean | undefined;
}) => Field<string, {}>;

declare const NumberField: (newOptions?: string | Partial<Omit<_flatfile_schema.BaseSchemaILField, "field"> & IFieldHooks<number> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.SchemaILEnumField, "field"> & IFieldHooks<number> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.LinkedSheetField, "field"> & IFieldHooks<number> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.ReferenceField, "field"> & IFieldHooks<number> & IExtraFieldOptions>) => Field<number, {}>;

type LabelObject = {
    label: string;
    value?: string | number | boolean;
};
type LabelOptions = string | LabelObject;
declare const OptionField: (newOptions: Partial<FieldOnlyOptions<string>> & {
    matchStrategy?: "fuzzy" | "exact" | undefined;
    options: Record<string, LabelOptions>;
}) => Field<string, {}>;

type ReferenceRelationship = 'has-one' | 'has-many';
declare const ReferenceField: (newOptions: Partial<FieldOnlyOptions<string>> & {
    sheetKey: string;
    foreignKey: string;
    relationship?: ReferenceRelationship | undefined;
}) => Field<string, {}>;

declare const TextField: (newOptions?: string | Partial<Omit<_flatfile_schema.BaseSchemaILField, "field"> & IFieldHooks<string> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.SchemaILEnumField, "field"> & IFieldHooks<string> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.LinkedSheetField, "field"> & IFieldHooks<string> & IExtraFieldOptions> | Partial<Omit<_flatfile_schema.ReferenceField, "field"> & IFieldHooks<string> & IExtraFieldOptions>) => Field<string, {}>;

type Format = 'full' | 'iso-2' | 'iso-3';
declare const CountryCast: (toFormat: Format) => (raw: Dirty<string>) => Nullable<string>;
declare const StateCast: (toFormat: 'full' | 'two-letter') => (raw: Dirty<string>) => Nullable<string>;
declare const StateAndTerritoryCast: (toFormat: 'full' | 'two-letter') => (raw: Dirty<string>) => Nullable<string>;

declare const SynonymCast: <FinalType>(matchingVals: [FinalType, string[]][], errorFunc: (wrongVal: string) => string) => (raw: Dirty<string> | FinalType) => Nullable<FinalType>;

declare const createBlueprintFromConfigure: (agent: Agent) => {
    name: string;
    slug: string;
    blueprints: Blueprint$1[];
} | undefined;

declare const StringCast: (raw: Dirty<string>) => string | null;
declare const ChainCast: <InitialType, FinalType>(firstCast: (raw: Dirty<InitialType>) => Nullable<InitialType>, secondCast: (raw: InitialType | FinalType) => Nullable<FinalType>) => (raw: FinalType | Dirty<InitialType>) => Nullable<FinalType>;
declare const StringChainCast: <FinalType>(secondCast: (raw: string | FinalType) => Nullable<FinalType>) => (raw: Dirty<string> | FinalType) => Nullable<FinalType>;
declare const StringCastCompose: <T>(recipientCast: (raw: string) => Nullable<T>) => (raw: Dirty<string> | T) => Nullable<T>;
declare const FallbackCast: <T>(firstCast: (raw: Dirty<T>) => Nullable<T>, fallbackCast: (raw: Dirty<T>) => Nullable<T>) => (raw: string | T | null) => T | null;
declare const NumberCast: (raw: number | Dirty<string>) => Nullable<number>;
declare const BooleanCast: (raw: boolean | Dirty<string>) => Nullable<boolean>;
declare const DateCast: (raw: string | undefined | null | number | Date) => Date | null;

declare const stdlibCast_BooleanCast: typeof BooleanCast;
declare const stdlibCast_ChainCast: typeof ChainCast;
declare const stdlibCast_DateCast: typeof DateCast;
declare const stdlibCast_FallbackCast: typeof FallbackCast;
declare const stdlibCast_NumberCast: typeof NumberCast;
declare const stdlibCast_StringCast: typeof StringCast;
declare const stdlibCast_StringCastCompose: typeof StringCastCompose;
declare const stdlibCast_StringChainCast: typeof StringChainCast;
declare namespace stdlibCast {
  export {
    stdlibCast_BooleanCast as BooleanCast,
    stdlibCast_ChainCast as ChainCast,
    stdlibCast_DateCast as DateCast,
    stdlibCast_FallbackCast as FallbackCast,
    stdlibCast_NumberCast as NumberCast,
    stdlibCast_StringCast as StringCast,
    stdlibCast_StringCastCompose as StringCastCompose,
    stdlibCast_StringChainCast as StringChainCast,
  };
}

declare const GenericDefaults: BaseSchemaILFieldArgs;
declare const mergeFieldOptions: <OperatingType>(base: FieldOnlyOptions<OperatingType>, other: Partial<FieldOnlyOptions<OperatingType>>) => FieldOnlyOptions<OperatingType>;
declare function makeField<T extends any, ExtraOptions extends Record<string, any> = {}>(baseField: Field<T>, newDefaults?: Partial<FieldOnlyOptions<T>>, customizer?: (mergedOptions: FieldOnlyOptions<T> & ExtraOptions, extraUserOptions: Partial<FieldOnlyOptions<T>> & ExtraOptions, baseField: FieldOnlyOptions<T>, newDefaults: Partial<FieldOnlyOptions<T> & ExtraOptions>) => Field<T>): (newOptions: Partial<FieldOnlyOptions<T>> & ExtraOptions) => Field<T>;

declare const stdlib: {
    cast: typeof stdlibCast;
};

export { Action, Agent, AnyField, BooleanField, ComputedField, CountryCast, DateField, Dirty, EventCallback, EventHandler, Field, FieldConfig, FieldHookDefaults, FieldOnlyOptions, FlatfileEvent, GenericDefaults, GroupByField, IExtraFieldOptions, IFieldHooks, IHookPayload, InfoObj, LinkedField, List, Message, Nullable, NumberField, OptionField, Portal, RecordCompute, RecordTranslater, RecordsComputeType, ReferenceField, ReferenceRelationship, Sheet, SheetOptions, SheetTester, SpaceConfig, StateAndTerritoryCast, StateCast, SynonymCast, TRecordStageLevel, TextField, UniqueAndRequiredPlugin, Waitable, Workbook, Writable, computeType, createBlueprintFromConfigure, makeField, matchMessages, matchSingleMessage, mergeFieldOptions, removeUndefineds, stdlib, verifyEgressCycle, wrapValidate };
